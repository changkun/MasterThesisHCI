<!DOCTYPE html>
<meta charset="utf-8">
<style>

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #444;
  stroke-width: 2.5px;
}

text {
  font-family: sans-serif;
  font-size: 10px;
}

</style>
<svg width="980" height="860"></svg>
<button id="generate">Save as SVG</button>
<script src="d3.v4.min.js"></script>
<script src="js/clickstream-task-4.js"></script>
<!-- <script src="js/clickstream-2-2.js"></script> -->
<script src="https://fastcdn.org/FileSaver.js/1.1.20151003/FileSaver.min.js"></script>
<script>

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

svg.append("rect")
    .attr("fill", "none")
    .attr("pointer-events", "all")
    .attr("width", width)
    .attr("height", height)

svg.append("svg:defs").append("svg:marker")
    .attr("id", "arrow")
    .attr("viewBox", "0 -5 10 10")
    .attr('refX', -20)//so that it comes towards the center.
    .attr("markerWidth", 8)
    .attr("markerHeight", 5)
    .attr("orient", "auto")
  .append("svg:path")
    .attr("d", "M0,-5L10,0L0,5");

var color = d3.scaleOrdinal(d3.schemeCategory20);

var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { 
        return d.id; 
    }))
    .force("charge", d3.forceManyBody())
    .force("center", d3.forceCenter(width / 2, height / 2));

var link = svg.append("g")
    .attr("class", "links")
    .selectAll("line")
    .data(graph.links)
    .enter().append("line")
    .attr('marker-start', (d) => "url(#arrow)")//attach the arrow from defs
    .attr("stroke-width", function(d) { return 1; /*Math.sqrt(d.stay_seconds);*/ });

var node = svg.append("g")
    .attr("class", "nodes")
    .selectAll("g")
    .data(graph.nodes)
    .enter().append("g")

var circles = node.append("circle")
    .attr("r", function(d) {
        // return d.stay_seconds;
        return Math.sqrt(d.stay_seconds);
    })
    .attr("fill", function(d, i) {
        return '#118531' // lmu color

        if (d.common_node === true) {
            return '#000000'
        }
        console.log(d.group%4)
        switch (d.group%4) {
            case 0:
                return '#1f77b4'
            case 1:
                return '#2ca02c'
            case 2:
                return '#ff9896'
            case 3:
                return '#8c564b'
        }
        console.log(color(i))
        // return color(1) // goal
        // return '#ff7f0e'; // fuzzy
        return '#9467bd'; // exploring


        // #1f77b4
        // #aec7e8
        // #ff7f0e
        // #ffbb78
        // #2ca02c
        // #98df8a
        // #d62728
        // #ff9896
        // #9467bd
        // #c5b0d5
        // #8c564b
        // #c49c94
        // #e377c2
        // #f7b6d2
        // #7f7f7f
        // #c7c7c7
    })
    .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

var lables = node
    .append("text")
    .text(function(d) {
        if (d.label == '') {
            return d.id;
        }
        return d.id;
    })
    .attr('x', 6)
    .attr('y', 3)

node.append("title")
    .text(function(d) {
        return d.label; 
    });

simulation
    .nodes(graph.nodes)
    .on("tick", ticked);

simulation
    .force("link")
    .links(graph.links);

function ticked() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; })
        .attr( "d", (d) => "M" + d.source.x + "," + d.source.y + ", " + d.target.x + "," + d.target.y)

    node.attr("transform", function(d) {
        return "translate(" + d.x + "," + d.y + ")";
    })
}

function dragstarted(d) {
    if (!d3.event.active) 
        simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
}

function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
}

function dragended(d) {
    if (!d3.event.active) 
        simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
}

d3.select('#generate').on('click', function(){
    saveSvgAsPng(d3.select('svg').node(), 'myDrawing.png');
});



// <!-- saveSvgAsPng - https://github.com/exupero/saveSvgAsPng -->
  (function() {
    var out$ = typeof exports != 'undefined' && exports || typeof define != 'undefined' && {} || this;

    var doctype = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">';

    function isExternal(url) {
      return url && url.lastIndexOf('http',0) == 0 && url.lastIndexOf(window.location.host) == -1;
    }

    function inlineImages(el, callback) {
      var images = el.querySelectorAll('image');
      var left = images.length;
      if (left == 0) {
        callback();
      }
      for (var i = 0; i < images.length; i++) {
        (function(image) {
          var href = image.getAttributeNS("http://www.w3.org/1999/xlink", "href");
          if (href) {
            if (isExternal(href.value)) {
              console.warn("Cannot render embedded images linking to external hosts: "+href.value);
              return;
            }
          }
          var canvas = document.createElement('canvas');
          var ctx = canvas.getContext('2d');
          var img = new Image();
          href = href || image.getAttribute('href');
          img.src = href;
          img.onload = function() {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            image.setAttributeNS("http://www.w3.org/1999/xlink", "href", canvas.toDataURL('image/png'));
            left--;
            if (left == 0) {
              callback();
            }
          }
          img.onerror = function() {
            console.log("Could not load "+href);
            left--;
            if (left == 0) {
              callback();
            }
          }
        })(images[i]);
      }
    }

    function styles(el, selectorRemap) {
      var css = "";
      var sheets = document.styleSheets;
      for (var i = 0; i < sheets.length; i++) {
        try {
          var rules = sheets[i].cssRules;
        } catch (e) {
          console.warn("Stylesheet could not be loaded: "+sheets[i].href);
          continue;
        }

        if (rules != null) {
          for (var j = 0; j < rules.length; j++) {
            var rule = rules[j];
            if (typeof(rule.style) != "undefined") {
              var match = null;
              try {
                match = el.querySelector(rule.selectorText);
              } catch(err) {
                console.warn('Invalid CSS selector "' + rule.selectorText + '"', err);
              }
              if (match) {
                var selector = selectorRemap ? selectorRemap(rule.selectorText) : rule.selectorText;
                css += selector + " { " + rule.style.cssText + " }\n";
              } else if(rule.cssText.match(/^@font-face/)) {
                css += rule.cssText + '\n';
              }
            }
          }
        }
      }
      return css;
    }

    function getDimension(el, clone, dim) {
      var v = (el.viewBox && el.viewBox.baseVal && el.viewBox.baseVal[dim]) ||
        (clone.getAttribute(dim) !== null && !clone.getAttribute(dim).match(/%$/) && parseInt(clone.getAttribute(dim))) ||
        el.getBoundingClientRect()[dim] ||
        parseInt(clone.style[dim]) ||
        parseInt(window.getComputedStyle(el).getPropertyValue(dim));
      return (typeof v === 'undefined' || v === null || isNaN(parseFloat(v))) ? 0 : v;
    }

    function reEncode(data) {
      data = encodeURIComponent(data);
      data = data.replace(/%([0-9A-F]{2})/g, function(match, p1) {
        var c = String.fromCharCode('0x'+p1);
        return c === '%' ? '%25' : c;
      });
      return decodeURIComponent(data);
    }

    out$.svgAsDataUri = function(el, options, cb) {
      options = options || {};
      options.scale = options.scale || 1;
      var xmlns = "http://www.w3.org/2000/xmlns/";

      inlineImages(el, function() {
        var outer = document.createElement("div");
        var clone = el.cloneNode(true);
        var width, height;
        if(el.tagName == 'svg') {
          width = options.width || getDimension(el, clone, 'width');
          height = options.height || getDimension(el, clone, 'height');
        } else if(el.getBBox) {
          var box = el.getBBox();
          width = box.x + box.width;
          height = box.y + box.height;
          clone.setAttribute('transform', clone.getAttribute('transform').replace(/translate\(.*?\)/, ''));

          var svg = document.createElementNS('http://www.w3.org/2000/svg','svg')
          svg.appendChild(clone)
          clone = svg;
        } else {
          console.error('Attempted to render non-SVG element', el);
          return;
        }

        clone.setAttribute("version", "1.1");
        clone.setAttributeNS(xmlns, "xmlns", "http://www.w3.org/2000/svg");
        clone.setAttributeNS(xmlns, "xmlns:xlink", "http://www.w3.org/1999/xlink");
        clone.setAttribute("width", width * options.scale);
        clone.setAttribute("height", height * options.scale);
        clone.setAttribute("viewBox", [
          options.left || 0,
          options.top || 0,
          width,
          height
        ].join(" "));

        outer.appendChild(clone);

        var css = styles(el, options.selectorRemap);
        var s = document.createElement('style');
        s.setAttribute('type', 'text/css');
        s.innerHTML = "<![CDATA[\n" + css + "\n]]>";
        var defs = document.createElement('defs');
        defs.appendChild(s);
        clone.insertBefore(defs, clone.firstChild);

        var svg = doctype + outer.innerHTML;
        var uri = 'data:image/svg+xml;base64,' + window.btoa(reEncode(svg));
        if (cb) {
          cb(uri);
        }
      });
    }

    out$.svgAsPngUri = function(el, options, cb) {
      out$.svgAsDataUri(el, options, function(uri) {
        var image = new Image();
        image.onload = function() {
          var canvas = document.createElement('canvas');
          canvas.width = image.width;
          canvas.height = image.height;
          var context = canvas.getContext('2d');
          if(options && options.backgroundColor){
            context.fillStyle = options.backgroundColor;
            context.fillRect(0, 0, canvas.width, canvas.height);
          }
          context.drawImage(image, 0, 0);
          var a = document.createElement('a'), png;
          try {
            png = canvas.toDataURL('image/png');
          } catch (e) {
            if ((typeof SecurityError !== 'undefined' && e instanceof SecurityError) || e.name == "SecurityError") {
              console.error("Rendered SVG images cannot be downloaded in this browser.");
              return;
            } else {
              throw e;
            }
          }
          cb(png);
        }
        image.src = uri;
      });
    }

    out$.saveSvgAsPng = function(el, name, options) {
      options = options || {};
      out$.svgAsPngUri(el, options, function(uri) {
        var a = document.createElement('a');
        a.download = name;
        a.href = uri;
        document.body.appendChild(a);
        a.addEventListener("click", function(e) {
          a.parentNode.removeChild(a);
        });
        a.click();
      });
    }

    // if define is defined create as an AMD module
    if (typeof define !== 'undefined') {
      define(function() {
        return out$;
      });
    }

  })();
</script>